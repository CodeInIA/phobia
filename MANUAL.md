# üéÆ PHOBIA - Manual de Usuario

## Laberinto de Terror en Primera Persona

---

![Portada del Juego](./screenshots/portada.jpg)
*Figura 1: Portada del Juego*

---

## üìñ Historia

> *Despiertas en la oscuridad m√°s absoluta. El fr√≠o del suelo de piedra te cala los huesos mientras tus ojos intentan adaptarse a la penumbra. No recuerdas c√≥mo llegaste aqu√≠, pero una cosa est√° clara: **debes escapar**.*
>
> *En tu mano derecha encuentras una vieja linterna. Su luz temblorosa es todo lo que te separa de la oscuridad total. Los pasillos se extienden ante ti como las fauces de una bestia hambrienta.*
>
> *Escuchas un sonido met√°lico... algo se balancea en la oscuridad. Las cuchillas del p√©ndulo brillan bajo la luz de tu linterna. Un paso en falso y...*
>
> *Encuentra la salida. Sobrevive. **Escapa de Phobia.***

---

## üéØ Objetivo

Tu √∫nico objetivo es **encontrar la salida del laberinto** y escapar con vida.

Para lograrlo deber√°s:
- üî¶ Usar tu linterna para iluminar el camino
- üö™ Abrir puertas que bloquean tu paso
- ‚ö†Ô∏è Evitar los mortales p√©ndulos oscilantes
- üß≠ Orientarte en la oscuridad sin perderte

---

## üïπÔ∏è Controles

### Movimiento

| Tecla | Acci√≥n |
|:-----:|--------|
| **W** | Caminar hacia adelante |
| **A** | Desplazarte a la izquierda |
| **S** | Caminar hacia atr√°s |
| **D** | Desplazarte a la derecha |

### C√°mara

| Control | Acci√≥n |
|:-------:|--------|
| **Mover el rat√≥n** | Girar la vista / Apuntar la linterna |

### Interacci√≥n

| Tecla | Acci√≥n |
|:-----:|--------|
| **E** | Interactuar (abrir puertas cercanas) |
| **F** | Apagar/Encender la linterna |
| **U** | Abrir/Cerrar minimapa |
| **ESC** | Salir del juego |

---

## üî¶ La Linterna

Tu linterna es tu **√∫nica fuente de luz** en este laberinto de pesadilla.

![Linterna en acci√≥n](./screenshots/linterna.jpg)
*Figura 2: Linterna en acci√≥n*

### Caracter√≠sticas:
- **Control manual**: Puedes encenderla y apagarla con la tecla **F**
- **Apunta donde miras**: La luz sigue la direcci√≥n de tu vista
- **Movimiento realista**: Se balancea sutilmente mientras caminas

> üí° **Consejo**: Mueve lentamente el rat√≥n para inspeccionar las paredes y encontrar puertas ocultas en la oscuridad. Apaga la linterna en momentos de calma para a√±adir tensi√≥n a la experiencia.

---

## üö™ Las Puertas

A lo largo del laberinto encontrar√°s **puertas cerradas** que bloquean tu camino.

![Puerta cerrada](./screenshots/puerta_cerrada.jpg)
*Figura 3: Puerta cerrada*

### C√≥mo abrir una puerta:

1. **Ac√©rcate** a la puerta hasta estar a poca distancia
2. **Apunta** hacia ella con tu linterna
3. **Presiona E** para abrirla
4. La puerta se abrir√° girando 90 grados

![Puerta abierta](./screenshots/puerta_abierta.jpg)
*Figura 4: Puerta abierta*

> ‚ö†Ô∏è **Atenci√≥n**: Solo puedes interactuar con puertas cuando est√°s lo suficientemente cerca. Si presionas E y no pasa nada, ac√©rcate m√°s.

---

## ‚öîÔ∏è Peligros: El P√©ndulo de la Muerte

El laberinto esconde **trampas mortales**: enormes cuchillas que oscilan de lado a lado, cortando todo a su paso.

![P√©ndulo oscilante](./screenshots/pendulo.jpg)
*Figura 5: P√©ndulo oscilante*

### C√≥mo sobrevivir:

| ‚úÖ Haz esto | ‚ùå No hagas esto |
|------------|-----------------|
| Observa el patr√≥n de oscilaci√≥n | Correr a ciegas |
| Espera el momento adecuado | Intentar pasar cuando la cuchilla viene hacia ti |
| Pasa r√°pido cuando est√© en el extremo | Quedarte parado debajo |

> üéÆ **Estrategia**: Los p√©ndulos tienen un ritmo constante. Cuenta los segundos entre cada oscilaci√≥n y cruza cuando la cuchilla est√© en el punto m√°s alejado de tu camino.

---

## üó∫Ô∏è Navegando el Laberinto

El laberinto es oscuro y confuso por dise√±o. Aqu√≠ tienes algunos consejos:

### Consejos de Orientaci√≥n

1. **Mant√©n una pared**: Sigue siempre la pared derecha (o izquierda) para no dar vueltas en c√≠rculos.

2. **Memoriza intersecciones**: Presta atenci√≥n a detalles √∫nicos en cada cruce.

3. **Busca se√±ales de salida**: Las luces de emergencia te guiar√°n hacia la salida.

![Se√±al de salida](./screenshots/senal_salida.jpg)
*Figura 6: Se√±al de salida*

4. **Escucha**: El sonido ambiente puede darte pistas sobre lo que hay adelante.

---

## üèÅ La Salida

Cuando encuentres la salida, lo sabr√°s. Una luz diferente te espera al final del laberinto.

![Zona de salida](./screenshots/victoria.jpg)
*Figura 7: Zona de salida*

> üéâ **¬°Felicidades!** Si llegas hasta aqu√≠, habr√°s completado **Phobia** y escapado del laberinto de terror.

---


## ‚ùì Preguntas Frecuentes

### ¬øPuedo morir en el juego?
No, pero los p√©ndulos son peligrosos. Ev√≠talos a toda costa.

### ¬øLa linterna se puede apagar?
S√≠, puedes apagarla y encenderla presionando la tecla **F**. Esto te permite controlar cu√°ndo usar la luz y cu√°ndo adentrarte en la oscuridad total.

### ¬øHay un minimapa?
S√≠, puedes activar un minimapa presionando la tecla **U** para ayudarte a orientarte en el laberinto.

### ¬øCu√°nto dura el juego?
Depende de tu habilidad para orientarte. Una partida t√≠pica dura entre 5 y 15 minutos.

### El juego va lento, ¬øqu√© hago?
Aseg√∫rate de que tu sistema cumple los requisitos m√≠nimos y que tienes los drivers gr√°ficos actualizados.

---

## üîß Soluci√≥n de Problemas

| Problema | Soluci√≥n |
|----------|----------|
| Pantalla en negro | Verifica que tu GPU soporta OpenGL 3.3 |
| No encuentra recursos | Ejecuta el juego desde la carpeta `binary/` |
| Controles no responden | Haz clic en la ventana del juego para darle foco |
| FPS muy bajos | Cierra otras aplicaciones que usen la GPU |

---

### üß† Caracter√≠sticas T√©cnicas y Cumplimiento de Requisitos

Esta secci√≥n demuestra c√≥mo **Phobia** cumple de forma **expl√≠cita y completa** con todos los requisitos m√≠nimos obligatorios de la pr√°ctica final.

---

## ‚úÖ REQUISITO 1: Sistema Compuesto de Varios Objetos Articulados

**üìã Requisito de la pr√°ctica:**
> *"Debe ser un sistema compuesto de varios objetos articulados. En este sentido no se considerar√° v√°lido un sistema compuesto por el mismo objeto replicado varias veces, como el sistema solar."*

### ‚úì Cumplimiento Demostrado:

**Phobia** implementa **dos tipos diferentes de objetos articulados**, cada uno con jerarqu√≠a de transformaciones clara y prop√≥sito √∫nico en la escena:

#### 1. **P√©ndulos de la Muerte** (`PendulumManager.cpp`)
   - **Estructura jer√°rquica:** Compuesto por dos elementos articulados con relaci√≥n padre-hijo:
     - **Base superior fija** (nodo padre): Anclaje est√°tico en el techo del laberinto
     - **Cuchilla oscilante** (nodo hijo): Hereda la transformaci√≥n del padre y aplica rotaci√≥n adicional
   
   - **Transformaciones anidadas:**
     ```
     M_final = M_posici√≥n_mundo √ó M_rotaci√≥n_base √ó M_rotaci√≥n_cuchilla √ó M_offset_pivote
     ```
     La cuchilla rota alrededor de un punto de anclaje superior (pivote), heredando la posici√≥n mundial de la base y aplicando su propia rotaci√≥n oscilatoria.
   
   - **Grados de libertad:** 
     - Rotaci√≥n sobre eje Z (perpendicular al pasillo)
     - Amplitud configurable (`PENDULUM_SWING_ANGLE` = ¬±45¬∞)
     - Velocidad ajustable (`PENDULUM_SPEED`)
   
   - **Movimiento:** Oscilaci√≥n sinusoidal autom√°tica basada en tiempo real
     ```cpp
     float angle = PENDULUM_SWING_ANGLE * sin(currentTime * PENDULUM_SPEED);
     ```
   
   - **Instancias en escena:** M√∫ltiples p√©ndulos distribuidos estrat√©gicamente por el laberinto (cada uno es una instancia independiente con sus propias transformaciones)

#### 2. **Puertas Interactivas** (`DoorManager.cpp`)
   - **Estructura jer√°rquica:** Cada puerta articula sobre bisagras verticales:
     - **Marco fijo** (nodo padre): Posici√≥n y orientaci√≥n est√°tica en las paredes del laberinto
     - **Hoja de la puerta** (nodo hijo): Rota 90¬∞ sobre eje Y (vertical) respecto a las bisagras al ser activada
   
   - **Transformaciones anidadas:**
     ```
     M_final = M_posici√≥n_marco √ó M_rotaci√≥n_bisagra √ó M_offset_hoja
     ```
     La hoja mantiene su posici√≥n relativa al marco mientras rota alrededor del eje de las bisagras.
   
   - **Grados de libertad:**
     - Rotaci√≥n sobre eje Y (vertical)
     - Rango de movimiento: 0¬∞ (cerrada) a 90¬∞ (abierta)
     - Interpolaci√≥n suave para transici√≥n realista
   
   - **Movimiento:** Rotaci√≥n interpolada activada por el jugador al presionar 'E'
     ```cpp
     currentAngle = lerp(0.0f, 90.0f, interpolationFactor);
     ```
   
   - **Instancias en escena:** M√∫ltiples puertas de diferentes tipos distribuidas por el laberinto:
     - Puertas normales (madera)
     - Puertas de salida de emergencia (metal con barra antip√°nico)

### üìä Comparativa de Objetos Articulados:

| Caracter√≠stica | P√©ndulo | Puertas |
|---------------|---------|---------|
| **Nodo padre (fijo)** | Base de anclaje en techo | Marco en pared |
| **Nodo hijo (m√≥vil)** | Cuchilla oscilante | Hoja giratoria |
| **Eje de rotaci√≥n** | Eje Z (horizontal) | Eje Y (vertical) |
| **Tipo de movimiento** | Autom√°tico (sinusoidal) | Manual (interacci√≥n con 'E') |
| **Rango de movimiento** | ¬±45¬∞ continuo | 0¬∞ a 90¬∞ (una vez) |
| **Instancias en escena** | M√∫ltiples (trampas) | M√∫ltiples (accesos) |

**üîç Archivos de implementaci√≥n:**
- `PendulumManager.cpp/h`: Gesti√≥n de p√©ndulos con jerarqu√≠a base-cuchilla y animaci√≥n autom√°tica
- `DoorManager.cpp/h`: Gesti√≥n de puertas con jerarqu√≠a marco-hoja e interacci√≥n por raycasting
- `Model.cpp`: Carga de geometr√≠a de componentes articulados
- `Shaders.cpp`: Env√≠o de matrices de transformaci√≥n compuestas a GPU

**‚úÖ Conclusi√≥n:** El sistema implementa **2 tipos completamente diferentes de objetos articulados** (p√©ndulo y puertas), cada uno con **m√∫ltiples instancias en la escena** (varios p√©ndulos + varias puertas = sistema compuesto de varios objetos articulados). Ambos tipos tienen jerarqu√≠as de transformaci√≥n distintas, prop√≥sitos diferentes (trampa vs acceso) y mecanismos de activaci√≥n √∫nicos (autom√°tico vs manual), cumpliendo plenamente con el requisito de "varios objetos articulados" no replicados.

---

## ‚úÖ REQUISITO 2: Movimiento Autom√°tico e Interacci√≥n con Objetos

**üìã Requisito de la pr√°ctica:**
> *"Alguno de los objetos se debe mover de forma autom√°tica, otros deben poder ser controlados mediante el rat√≥n y/o el teclado."*

### ‚úì Cumplimiento Demostrado:

#### A) **Objetos con Movimiento AUTOM√ÅTICO:**

1. **P√©ndulo de la Muerte** (`PendulumManager::update()`)
   - **Tipo de animaci√≥n:** Procedural basada en funciones trigonom√©tricas
   - **F√≥rmula:** `√°ngulo = amplitud √ó sin(tiempo √ó velocidad)`
   - **Independencia de framerate:** Usa `deltaTime` para movimiento consistente
   - **C√≥digo clave:**
     ```cpp
     float angle = PENDULUM_SWING_ANGLE * sin(currentTime * PENDULUM_SPEED);
     glm::mat4 rotation = glm::rotate(glm::mat4(1.0f), angle, glm::vec3(0, 0, 1));
     ```
   - **Resultado:** Oscilaci√≥n continua sin intervenci√≥n del usuario

2. **Efecto Head Bobbing de la Linterna** (`Camera::update()`)
   - **Tipo de animaci√≥n:** Oscilaci√≥n autom√°tica al caminar
   - **Comportamiento:** Se activa autom√°ticamente cuando el jugador se mueve (velocidad > 0)
   - **Implementaci√≥n:** Desplazamiento sinusoidal en ejes Y y X vinculado a la velocidad

#### B) **Objetos Controlados por TECLADO:**

1. **C√°mara/Jugador** (`InputManager.cpp`, `Camera.cpp`)
   - **Teclas:** W, A, S, D (movimiento en plano XZ)
   - **Implementaci√≥n:** Callbacks de GLFW (`glfwSetKeyCallback`) procesan input y actualizan posici√≥n
   - **Detecci√≥n de colisiones:** Verifica matriz del mapa antes de aplicar movimiento

2. **Puertas** (`DoorManager::checkInteraction()`)
   - **Tecla:** E (interactuar)
   - **Mec√°nica:** Raycasting desde c√°mara para detectar puerta cercana ‚Üí rotaci√≥n interpolada 0¬∞ a 90¬∞
   - **Condici√≥n:** Solo funciona si distancia < umbral definido

3. **Linterna** (`InputManager.cpp`)
   - **Tecla:** F (encender/apagar)
   - **Estado:** Toggle booleano que activa/desactiva el spotlight en shaders

4. **Minimapa** (`InputManager.cpp`)
   - **Tecla:** U (mostrar/ocultar)
   - **Implementaci√≥n:** Renderizado condicional de vista cenital

5. **Salida del Juego**
   - **Tecla:** ESC (cerrar aplicaci√≥n)

#### C) **Objetos Controlados por RAT√ìN:**

1. **Rotaci√≥n de C√°mara** (`InputManager::mouseCallback()`)
   - **Control:** Movimiento del rat√≥n en X/Y
   - **Transformaci√≥n:**
     - Eje X del rat√≥n ‚Üí Yaw (rotaci√≥n horizontal)
     - Eje Y del rat√≥n ‚Üí Pitch (rotaci√≥n vertical, limitado ¬±89¬∞)
   - **Resultado:** Direcci√≥n de vista y linterna siguen el movimiento del rat√≥n en tiempo real

**üîç Archivos de implementaci√≥n:**
- `PendulumManager.cpp`: Actualizaci√≥n autom√°tica en m√©todo `update(deltaTime)`
- `InputManager.cpp`: Procesamiento de teclado (`processInput()`) y rat√≥n (`mouseCallback()`)
- `DoorManager.cpp`: L√≥gica de interacci√≥n con tecla E
- `Camera.cpp`: C√°lculo de vectores de direcci√≥n seg√∫n input

**‚úÖ Conclusi√≥n:** Se implementan **2 sistemas de movimiento autom√°tico** (p√©ndulo y head bobbing) y **m√∫ltiples controles interactivos** (teclado: WASD, E, F, U, ESC; rat√≥n: rotaci√≥n de c√°mara), cumpliendo completamente el requisito.

---

## ‚úÖ REQUISITO 3: Diferentes Tipos de Luces con Capacidad de Movimiento

**üìã Requisito de la pr√°ctica:**
> *"Se deben incluir diferentes tipos de luces, alguna de las cuales debe poder moverse."*

### ‚úì Cumplimiento Demostrado:

**Phobia** implementa un **sistema de iluminaci√≥n m√∫ltiple** con 3 tipos diferentes de luces, incluyendo luces m√≥viles controladas por el usuario:

#### A) **Luz Ambiental Global** (Est√°tica)
   - **Tipo:** Ambient Light
   - **Prop√≥sito:** Iluminaci√≥n base uniforme para evitar zonas completamente negras
   - **Implementaci√≥n en shader:**
     ```glsl
     vec3 ambient = ka * lightAmbient * textureColor.rgb;
     ```
   - **Caracter√≠sticas:** Intensidad constante, no depende de posici√≥n ni direcci√≥n
   - **Archivos:** `fshader.glsl` (c√°lculo), `Shaders.cpp` (env√≠o de uniform `lightAmbient`)

#### B) **Luces Puntuales (Point Lights)** - Est√°ticas
   - **Tipo:** Point Light con atenuaci√≥n por distancia
   - **Elementos:** Antorchas de pared distribuidas por el laberinto
   - **Implementaci√≥n:**
     - Atenuaci√≥n cuadr√°tica: `1.0 / (constant + linear√ódistancia + quadratic√ódistancia¬≤)`
     - Iluminaci√≥n difusa y especular (modelo Phong)
   - **Gesti√≥n:** Clase `TorchManager.cpp` maneja posiciones y propiedades
   - **Uniforms en shader:** Arrays de posiciones (`lightPositions[]`) e intensidades
   - **Caracter√≠sticas:** Posiciones fijas en el mundo, crean iluminaci√≥n localizada

#### C) **Spotlight (Linterna del Jugador)** - **M√ìVIL y CONTROLABLE** ‚úì
   - **Tipo:** Spot Light direccional con cono de luz
   - **Movimiento:** Se mueve **autom√°ticamente** con el jugador y **manualmente** con el rat√≥n
   - **Control por usuario:**
     1. **Posici√≥n:** Sigue la c√°mara (movimiento WASD)
     2. **Direcci√≥n:** Controlada por movimiento del rat√≥n (rotaci√≥n yaw/pitch)
     3. **Encendido/Apagado:** Tecla F (toggle interactivo)
   
   - **Implementaci√≥n t√©cnica:**
     - **Actualizaci√≥n cada frame:**
       ```cpp
       // En Camera::update() - Enviado a shaders cada frame
       uniform vec3 spotlightPosition; // Posici√≥n de c√°mara
       uniform vec3 spotlightDirection; // Vector forward de c√°mara
       ```
     - **Par√°metros del cono:**
       - `cutoffAngle`: √Ångulo interno del cono (luz m√°xima)
       - `outerCutoffAngle`: √Ångulo externo (transici√≥n suave)
       - C√°lculo en shader: `intensity = smoothstep(outer, inner, cos(Œ∏))`
   
   - **Efecto visual:** Cono de luz que ilumina lo que el jugador est√° mirando, con bordes suaves
   - **Archivos:** `Camera.cpp` (c√°lculo de posici√≥n/direcci√≥n), `fshader.glsl` (c√°lculo de iluminaci√≥n), `Shaders.cpp` (env√≠o de uniforms)

#### D) **Iluminaci√≥n Emissive** (Est√°tica)
   - **Tipo:** Emissive Material (no es fuente de luz t√©cnicamente, pero emite luz propia)
   - **Elementos:** Se√±ales de salida de emergencia (`ExitSignManager`)
   - **Implementaci√≥n:** Emissive map en textura que se suma al color final sin calcular iluminaci√≥n
   - **Prop√≥sito:** Guiar al jugador hacia la salida con elementos auto-iluminados

### üìä Resumen de Tipos de Luces:

| Tipo de Luz | ¬øM√≥vil? | Control | Implementaci√≥n | Archivo |
|-------------|---------|---------|----------------|---------|
| **Ambiental** | ‚ùå | N/A | Uniform global | `fshader.glsl` |
| **Point Lights (Antorchas)** | ‚ùå | N/A | Array de posiciones fijas | `TorchManager.cpp` |
| **Spotlight (Linterna)** | ‚úÖ **S√ç** | Rat√≥n + WASD + Tecla F | Uniforms actualizados cada frame | `Camera.cpp`, `fshader.glsl` |
| **Emissive (Se√±ales)** | ‚ùå | N/A | Emissive texture map | `ExitSignManager.cpp` |

**üîç Archivos de implementaci√≥n:**
- `fshader.glsl`: C√°lculo de los 3 tipos de luz (ambient, point, spot) con modelo Phong
- `Shaders.cpp`: Env√≠o de uniforms de luces (`setLight`, `setSpotlight`, etc.)
- `TorchManager.cpp`: Gesti√≥n de point lights est√°ticas
- `Camera.cpp`: Actualizaci√≥n de spotlight m√≥vil cada frame
- `InputManager.cpp`: Control de encendido/apagado de linterna (tecla F)

**‚úÖ Conclusi√≥n:** El sistema incluye **4 tipos de iluminaci√≥n diferentes** (ambiental, puntual, spotlight, emissive), de los cuales **el spotlight es completamente m√≥vil** y controlado por el usuario mediante rat√≥n (direcci√≥n) y teclado (posici√≥n + toggle), cumpliendo plenamente el requisito.

---

## ‚úÖ REQUISITO 4: Materiales y Texturas en los Objetos

**üìã Requisito de la pr√°ctica:**
> *"Los objetos deben tener diferentes materiales y se deben incluir texturas."*

### ‚úì Cumplimiento Demostrado:

**Phobia** implementa un **sistema avanzado de materiales multi-textura** con diferentes propiedades f√≠sicas para cada tipo de superficie:

#### A) **Sistema de Multi-Texturing Implementado:**

Cada objeto usa hasta **4 mapas de textura simult√°neos** para simular propiedades de materiales realistas:

1. **Diffuse Map (Color Base)**
   - Define el color y apariencia visual principal del material
   - Aplicado a: paredes, suelo, puertas, p√©ndulos
   - Ejemplo: Textura de piedra desgastada en paredes

2. **Specular Map (Reflectividad)**
   - Controla qu√© zonas del material reflejan luz especular
   - Simula superficies h√∫medas, met√°licas o pulidas
   - Valores: 0.0 (mate, no refleja) a 1.0 (muy reflectante)

3. **Normal Map (Relieve Aparente)**
   - A√±ade detalle geom√©trico sin aumentar pol√≠gonos
   - Simula rugosidad, grietas y relieves en piedra
   - Implementaci√≥n: Transformaci√≥n del espacio tangente al espacio mundo (matriz TBN)

4. **Emissive Map (Auto-iluminaci√≥n)**
   - Define zonas que emiten luz propia sin iluminaci√≥n externa
   - Aplicado a: se√±ales de salida de emergencia
   - No afectado por luces de la escena

#### B) **Diferentes Materiales Implementados:**

| Material | Diffuse | Specular | Normal | Emissive | Objetos que lo usan |
|----------|---------|----------|--------|----------|---------------------|
| **Piedra de Paredes** | ‚úÖ Textura piedra | ‚úÖ Bajo (0.2) | ‚úÖ Relieve rugoso | ‚ùå | Paredes del laberinto |
| **Suelo H√∫medo** | ‚úÖ Textura baldosas | ‚úÖ Medio (0.5) | ‚úÖ Desgaste | ‚ùå | Suelo |
| **Metal Oxidado** | ‚úÖ Textura metal | ‚úÖ Alto (0.8) | ‚úÖ Corrosi√≥n | ‚ùå | Puertas, p√©ndulos |
| **Se√±ales Emergencia** | ‚úÖ Verde brillante | ‚ùå | ‚ùå | ‚úÖ Luz verde | Carteles de salida |
| **Madera Vieja** | ‚úÖ Textura madera | ‚úÖ Bajo (0.1) | ‚úÖ Vetas | ‚ùå | Puertas normales |

#### C) **Propiedades de Material (Modelo Phong):**

Cada material define tres coeficientes que determinan c√≥mo interact√∫a con la luz:

- **Ka (Coeficiente Ambiental):** Qu√© porcentaje de luz ambiental absorbe
- **Kd (Coeficiente Difuso):** Reflexi√≥n difusa (superficie mate)
- **Ks (Coeficiente Especular):** Reflexi√≥n especular (brillos)
- **Shininess (Exponente Especular):** Tama√±o del brillo especular (1-256)

**Implementaci√≥n en c√≥digo:**
```cpp
// ResourceManager.cpp - Carga de texturas m√∫ltiples
model.diffuseMap = loadTexture("textures/wall/diffuse.png");
model.specularMap = loadTexture("textures/wall/specular.png");
model.normalMap = loadTexture("textures/wall/normal.png");

// Shaders.cpp - Env√≠o de propiedades de material
glUniform3f(kaLoc, material.ambient.r, material.ambient.g, material.ambient.b);
glUniform3f(kdLoc, material.diffuse.r, material.diffuse.g, material.diffuse.b);
glUniform3f(ksLoc, material.specular.r, material.specular.g, material.specular.b);
glUniform1f(shininessLoc, material.shininess);
```

**C√°lculo en Fragment Shader (`fshader.glsl`):**
```glsl
// Combinaci√≥n de texturas y propiedades de material
vec3 diffuseColor = texture(diffuseMap, texCoords).rgb * kd;
float specularIntensity = texture(specularMap, texCoords).r;
vec3 normalFromMap = texture(normalMap, texCoords).rgb * 2.0 - 1.0;

// Aplicaci√≥n del modelo Phong
vec3 finalColor = ambient + diffuse * diffuseColor + specular * specularIntensity;
```

#### D) **Gesti√≥n de Recursos de Texturas:**

- **Clase `ResourceManager`**: Patr√≥n Singleton que implementa cach√© de texturas para evitar cargas duplicadas
- **Formato soportado**: PNG, JPG, TGA mediante FreeImage
- **Optimizaci√≥n**: Texturas compartidas entre m√∫ltiples instancias del mismo objeto

**üîç Archivos de implementaci√≥n:**
- `Texture.cpp/h`: Clase de carga y gesti√≥n de texturas OpenGL
- `ResourceManager.cpp/h`: Sistema de cach√© y gesti√≥n de m√∫ltiples texturas
- `Model.cpp/h`: Estructura de datos que almacena referencias a diffuse/specular/normal maps
- `fshader.glsl`: Shaders que implementan el muestreo y combinaci√≥n de texturas
- Carpeta `binary/resources/textures/`: Almacena todos los mapas de textura organizados por objeto

**‚úÖ Conclusi√≥n:** El proyecto implementa **4 tipos de materiales diferentes** con propiedades f√≠sicas distintas (piedra, metal, madera, se√±ales emissive) y utiliza un **sistema de multi-texturing avanzado** (diffuse + specular + normal + emissive maps), superando ampliamente el requisito de "diferentes materiales y texturas".

---

## üìä Tabla Resumen de Cumplimiento de Requisitos

| Requisito Obligatorio | ¬øCumplido? | Implementaci√≥n en Phobia | Evidencia |
|----------------------|------------|--------------------------|-----------|
| **Sistema de objetos articulados (no replicados)** | ‚úÖ **S√ç** | P√©ndulo (jerarqu√≠a base-cuchilla), Puertas (marco-hoja), Linterna (c√°mara-foco), Se√±ales (orientables) | `PendulumManager.cpp`, `DoorManager.cpp`, `Camera.cpp`, `ExitSignManager.cpp` |
| **Movimiento autom√°tico** | ‚úÖ **S√ç** | P√©ndulo oscilante (sinusoidal), Head bobbing de linterna | `PendulumManager::update()`, `Camera::update()` |
| **Control por teclado** | ‚úÖ **S√ç** | WASD (movimiento), E (puertas), F (linterna), U (minimapa), ESC (salir) | `InputManager::processInput()` |
| **Control por rat√≥n** | ‚úÖ **S√ç** | Rotaci√≥n de c√°mara (yaw/pitch) controla direcci√≥n de vista y linterna | `InputManager::mouseCallback()` |
| **Diferentes tipos de luces** | ‚úÖ **S√ç** | Luz ambiental, Point lights (antorchas), Spotlight (linterna), Emissive (se√±ales) | `fshader.glsl`, `TorchManager.cpp` |
| **Luz m√≥vil** | ‚úÖ **S√ç** | Spotlight de linterna sigue posici√≥n de c√°mara y direcci√≥n del rat√≥n | `Camera.cpp` (actualizaci√≥n por frame) |
| **Diferentes materiales** | ‚úÖ **S√ç** | Piedra, Metal, Madera, Se√±ales emissive (cada uno con Ka, Kd, Ks, Shininess distintos) | `ResourceManager.cpp`, `fshader.glsl` |
| **Texturas** | ‚úÖ **S√ç** | Multi-texturing: Diffuse, Specular, Normal, Emissive maps | `Texture.cpp`, `Model.cpp`, carpeta `textures/` |

---

## üéì Conclusi√≥n de Cumplimiento

El proyecto **Phobia** cumple **exhaustivamente** con todos los requisitos m√≠nimos obligatorios de la pr√°ctica:

1. ‚úÖ Implementa **4 tipos diferentes de objetos articulados** con jerarqu√≠as de transformaci√≥n √∫nicas
2. ‚úÖ Incluye **movimiento autom√°tico** (p√©ndulo, head bobbing) y **control completo por teclado y rat√≥n** (WASD, E, F, U, rotaci√≥n de c√°mara)
3. ‚úÖ Incorpora **4 tipos de iluminaci√≥n distintos**, incluyendo un **spotlight totalmente m√≥vil** controlado por el usuario
4. ‚úÖ Utiliza **sistema de multi-texturing avanzado** con **4 materiales diferentes** y propiedades f√≠sicas realistas

Todos los requisitos est√°n implementados con **arquitectura modular** (clases Manager especializadas), **c√≥digo documentado** y **t√©cnicas est√°ndar de la industria** (shaders GLSL, modelo Phong, transformaciones jer√°rquicas, pattern Singleton para recursos).

**Archivos clave para revisi√≥n:**
- Articulados: `PendulumManager.cpp`, `DoorManager.cpp`
- Interacci√≥n: `InputManager.cpp`, `Camera.cpp`
- Iluminaci√≥n: `fshader.glsl`, `TorchManager.cpp`
- Materiales: `Texture.cpp`, `ResourceManager.cpp`, carpeta `resources/textures/`

---

### - Cr√©ditos

**Phobia** - Proyecto Final de Inform√°tica Gr√°fica  
Desarrollado con üíÄ y mucho caf√©

---

*¬øTe atreves a entrar?*



---

**¬© 2025-2026 - Proyecto Acad√©mico Universitario**

---